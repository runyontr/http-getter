// Copyright Â© 2018 NAME HERE <EMAIL ADDRESS>
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/spf13/cobra"

	"github.com/prometheus/client_golang/prometheus"

	"github.com/gorilla/mux"
)

// var timeout_env = os.Getenv("TIMEOUT")
var url = os.Getenv("URL")
var verbose = os.Getenv("VERBOSE")

// var method = os.Getenv("METHOD")

// doCmd represents the do command
var doCmd = &cobra.Command{
	Use:   "do",
	Short: "Does the configured http request.",

	Run: func(cmd *cobra.Command, args []string) {
		//parse from env later
		timeout := 1000

		//Setup prometheus
		httpReqs := prometheus.NewCounterVec(
			prometheus.CounterOpts{
				Name: "curl_response_total",
				Help: "How many HTTP requests processed, partitioned by status code and HTTP method.",
			},
			[]string{"code", "url", "method"},
		)
		prometheus.MustRegister(httpReqs)

		httpResponseTime := prometheus.NewSummaryVec(prometheus.SummaryOpts{
			Name:       "curl_response_time",
			Help:       "Time taken to respond to request.  partitioned by status code and HTTP method.",
			Objectives: map[float64]float64{0.5: 0.05, 0.9: 0.01, 0.99: 0.001},
		},
			[]string{"code", "url", "method"})
		prometheus.MustRegister(httpResponseTime)

		go func() {
			r := mux.NewRouter()
			r.Handle("/metrics", prometheus.InstrumentHandler(
				"metrics", prometheus.UninstrumentedHandler(),
			))
			s := &http.Server{
				Addr:           ":8080",
				ReadTimeout:    8 * time.Second,
				WriteTimeout:   8 * time.Second,
				MaxHeaderBytes: 1 << 20,
				Handler:        r,
			}
			log.Fatal(s.ListenAndServe())
		}()

		if url == "" {
			logrus.Errorf("Must provide URL value via 'URL' environment variable")
			os.Exit(1)
		}

		if !strings.HasPrefix(url, "http") {
			url = "http://" + url
		}
		for {
			time.Sleep(time.Duration(timeout) * time.Millisecond)
			// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
			startTime := time.Now()
			resp, err := http.Get(url)
			duration := time.Since(startTime)
			if err != nil {
				logrus.Errorf("Error getting from %v: %v", url, err)
				code := -1
				if resp != nil {
					code = resp.StatusCode
				}
				httpResponseTime.WithLabelValues(fmt.Sprintf("%v", code), url, "GET").Observe(float64(duration))
				continue
				// handle err
			}
			defer resp.Body.Close()

			s := fmt.Sprintf("%v %v %v", url, resp.StatusCode, duration)

			if verbose == "true" {
				body, _ := ioutil.ReadAll(resp.Body)
				s += fmt.Sprintf("\n%v", string(body))
			}
			fmt.Println(s)

			httpResponseTime.WithLabelValues(fmt.Sprintf("%v", resp.StatusCode), url, "GET").Observe(float64(duration))
		}
	},
}

func init() {
	rootCmd.AddCommand(doCmd)
}
